from datetime import datetime, timedelta
from airflow import DAG
from airflow.decorators import task
from airflow.models import DagRun
from airflow.operators.empty import EmptyOperator
from airflow.utils.trigger_rule import TriggerRule
from airflow.utils.session import provide_session
from airflow.api.common.experimental.trigger_dag import trigger_dag
import logging, time

# -----------------------------
# Configurations
# -----------------------------
CONFIG_IDS = ["config_001", "config_002", "config_003"]
MAIN_DAG_ID = "validation_job_dag"  # child DAG

default_args = {
    "owner": "data-engineering",
    "depends_on_past": False,
    "start_date": datetime(2024, 1, 1),
    "retries": 1,
    "retry_delay": timedelta(minutes=5),
}


# -----------------------------
# Controller DAG
# -----------------------------
with DAG(
    dag_id="controller_validation_dag",
    default_args=default_args,
    schedule_interval=None,
    catchup=False,
    max_active_runs=1,
    tags=["controller", "validation"],
) as dag:

    start = EmptyOperator(task_id="start")

    # --------------------------
    # Step 1: Trigger child DAGs
    # --------------------------
    @task
    def trigger_main_dag(config_id: str):
        """Trigger one run of MAIN_DAG_ID and return its run_id."""
        run_id = f"{config_id}__{datetime.utcnow().isoformat()}"
        dr = trigger_dag(
            dag_id=MAIN_DAG_ID,
            run_id=run_id,
            conf={"config_id": config_id},
            replace_microseconds=False,
        )
        logging.info(f"Triggered {MAIN_DAG_ID} for {config_id} with run_id={dr.run_id}")
        return {"config_id": config_id, "run_id": dr.run_id}

    triggered_runs = trigger_main_dag.expand(config_id=CONFIG_IDS)

    # --------------------------
    # Step 2: Wait for each run
    # --------------------------
    @task
    def wait_for_run(run_info: dict, poke_interval=60, timeout=7200):
        """Poll Airflow metadata DB for a specific DAG run until it finishes."""
        config_id = run_info["config_id"]
        run_id = run_info["run_id"]
        deadline = datetime.utcnow() + timedelta(seconds=timeout)

        @provide_session
        def get_state(session=None):
            dr = (
                session.query(DagRun)
                .filter(DagRun.dag_id == MAIN_DAG_ID, DagRun.run_id == run_id)
                .first()
            )
            return dr.state if dr else None

        while datetime.utcnow() < deadline:
            state = get_state()
            if state in ["success", "failed"]:
                logging.info(f"âœ… Run {run_id} ({config_id}) finished with state={state}")
                return {"config_id": config_id, "run_id": run_id, "state": state}

            logging.info(f"â³ Waiting for {config_id} / {run_id}, current state={state}")
            time.sleep(poke_interval)

        raise TimeoutError(f"â° Run {run_id} for {config_id} timed out")

    monitored = wait_for_run.expand(run_info=triggered_runs)

    # --------------------------
    # Step 3: Summarize results
    # --------------------------
    @task(trigger_rule=TriggerRule.ALL_DONE)
    def summarize(results: list):
        summary = {r["config_id"]: r["state"] for r in results}
        total = len(results)
        success = sum(1 for s in summary.values() if s == "success")
        failed = sum(1 for s in summary.values() if s == "failed")

        logging.info(f"ðŸ“Š Validation Summary: Total={total}, Success={success}, Failed={failed}")
        for cfg, state in summary.items():
            logging.info(f" - {cfg}: {state}")

        return {"total": total, "success": success, "failed": failed, "results": summary}

    summary = summarize(monitored)

    # --------------------------
    # Step 4: Notification
    # --------------------------
    @task(trigger_rule=TriggerRule.ALL_DONE)
    def send_notification(summary: dict):
        emoji = "âœ…" if summary["failed"] == 0 else "âš ï¸"
        msg = f"""
{emoji} Controller DAG Report

Total Configs: {summary['total']}
âœ… Success: {summary['success']}
âŒ Failed: {summary['failed']}

Details: {summary['results']}
"""
        logging.info(msg)
        return msg

    notify = send_notification(summary)

    end = EmptyOperator(task_id="end", trigger_rule=TriggerRule.ALL_DONE)

    # --------------------------
    # DAG Flow
    # --------------------------
    start >> triggered_runs >> monitored >> summary >> notify >> end
